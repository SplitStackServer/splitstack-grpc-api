syntax = "proto3";

package bs;

option go_package = "github.com/SplitStackServer/splitstack-grpc-api/bs";
option java_package = "io.splitstack.api.bs";
option java_multiple_files = true;
option java_outer_classname = "EndnodeProto";
option csharp_namespace = "SplitStackServer.Basestation";
option php_namespace = "SplitStackServer\\Basestation";
option php_metadata_namespace = "GPBMetadata\\SplitStackServer\\Basestation";

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";

message EndnodeUplink {
    // Basestation EUI, hex string
    string bs_eui = 1;

    // Message timestamp.
    google.protobuf.Timestamp ts = 2;



    // Message.
    oneof message {
        // Over the air attachment
        EndnodeAttMessage att = 4;
        // Over the air detachment
        EndnodeDetMessage det = 5;
        // Uplink payload
        EndnodeUlDataMessage ul_data = 6;
        // Variable Mac Uplink Payload
        EndnodeVariableMacUlDataMessage vm_ul_data = 7;
    }

    // Metadata.
    EndnodeUplinkMetadata meta = 8;
}

message EndnodeAttMessage {
    // Endnode EUI, hex string
    string ep_eui = 2;

    // Attachment_cnt counter.
    uint32 attachment_cnt = 3;

    // End Point nonce, 4 bytes little endian
    uint32 nonce = 4;

    // End Point signature, 4 bytes little endian
    uint32 sign = 5;

    // End Point short address, only if assigned by the Base Station, 2 bytes little endian
    optional uint32 sh_addr = 6;

    // True if End Point uses dual channel mode
    bool dual_channel = 7;

    // True if End Point uses DL repetition
    bool repetition = 8;

    // True if End Point uses wide carrier offset
    bool wide_carr_off = 9;

    // True if End Point uses long DL interblock distance
    bool long_blk_dist = 10;
}

message EndnodeDetMessage {
    // Endnode EUI, hex string
    string ep_eui = 2;
    // End Point signature , 4 bytes little endian
    uint32 sign = 3;

}

message EndnodeUlDataMessage {
    // Endnode EUI, hex string
    string ep_eui = 1;
    // End Point user data, might be empty
    bytes data = 2;
    // MPF header byte, 1 byte
    uint32 format = 3;
    // mioty Mode. (Optional)
    optional string mode = 4;
    // True if End Point downlink window is opened
    bool dl_open = 5;
    // True if End Point expects a response in the DL window, requires dl_open
    bool response_exp = 6;
    // True if End Point acknowledges the reception of a DL transmission in the last DL window (packetCnt - 1)
    bool dl_ack = 7;
}

message EndnodeUplinkMetadata {
    // ID of the operation, only valid for the respective basestation
    int64 op_id = 1;
    // Basestation RX time.
    google.protobuf.Timestamp rx_time = 2;
    // Duration of the reception. (Optional)
    optional google.protobuf.Duration rx_duration = 3;
    // Packet counter.
    uint32 packet_cnt = 4;
    // Profile. (Optional)
    optional string profile = 5;
    // RSSI.
    double rssi = 6;
    // SNR.
    double snr = 7;
    // AWGN equivalent reception SNR. (Optional)
    optional double eq_snr = 8;
    // Reception info for every subpacket. (Optional)
    repeated EndnodeUplinkSubpacket subpacket_info = 9;
}

message EndnodeUplinkSubpacket {
    // Subpacket signal to noise ratio in dB.
    int32 snr = 1;

    // Subpacket signal strength in dBm.
    int32 rssi = 2;

    // Subpacket frequencies in Hz.
    int32 frequency = 3;

    // Subpacket phases in degree +-180. (Optional)
    optional int32 phase = 4;
}

enum CarrierSpacingEnum {
    NARROW = 0;
    STANDARD = 1;
    WIDE = 2;
}

enum TsmaPatternGroupEnum {
    NORMAL = 0;
    REPETITION = 1;
    LOW_DELAY = 2;
}

message EndnodeVariableMacUlDataMessage {
    // n Byte End Point user data U-MPDU; starting with first byte after MAC-Type
    bytes data = 1;
    // MAC-Type of Variable MAC, 1 byte
    uint32 mac_type = 2;
    // Frequency offset from center between primary and secondary channel in Hz 
    double freq_off = 5;
    // Carrier spacing step size Bc, 0 = narrow, 1 = standard, 2 = wide
    CarrierSpacingEnum carr_space = 6;
    // Uplink TSMA Pattern group, 0 = normal, 1 = repetition, 2 = low delay
    TsmaPatternGroupEnum patt_grp = 7;
    // Uplink TSMA Pattern number p
    uint32 patt_num = 8;
    // Header and payload CRC, crc[0] = header CRC, crc[1] = payload CRC
    uint64 crc = 9;
}
